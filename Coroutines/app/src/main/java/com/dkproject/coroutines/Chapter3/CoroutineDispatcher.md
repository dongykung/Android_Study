## CoroutineDispatcher란 무엇인가?
dispatcher = "무언가를 보내는 주체"
그렇다면 CoroutineDispatcher 객체는 코루틴을 어디로 보내는 것일까?
#### 바로 스레드이다.

코루틴은 일시 중단이 가능한 '작업'이기 때문에 스레드가 있어야 실행될 수 있으며, CoroutineDispatcher는 코루틴을 스레드로 보내 실행시키는 역활을 한다.
CoroutineDispatcher는 코루틴을 스레드로 보내는 데 사용할 수 있는 스레드나 스레드풀을 가지며, 코루틴을 실행 요청한 스레드에서 코루틴이 실행되도록 만들 수 있다.

CoroutineDispatcher 객체는 실행돼야 하는 작업을 저장하는 작업 대기열을 가진다.

만약 스레드풀에 스레드가 2개 있고 스레드1에는 코루틴1이, 스레드2에는 코루틴2가 적재되어 있다고 가정해보자.
이 때 작업 대기열에 코루틴3이 들어왔다. 
현재 모든 스레드가 코루틴을 실행 중이여서 CoroutineDispatcher 객체는 사용할 수 있는 스레드가 없다.
따라서 작업 대기열에서 대기하도록 둔다.
Coroutine3 코루틴이 스레드로 보내지는 시점은 스레드풀의 스레드 중 하나가 자유로워졌을 때이다.

즉 적재한 후 사용할 수 있는 스레드가 생기면 스레드로 보내는 방식으로 동작.

## 제한된 디스패처와 무제한 디스패처

### 제한된 디스패처(Confined Dispatcher)
사용할 수 있는 스레드나 스레드풀이 제한됨(대부분의 객체는 제한된 디스패처)
코루틴을 실행시킬 때 보낼 수 있는 스레드가 제한된 CoroutineDispatcher 객체

### 무제한 디스패처(Unconfined Dispatcher)
사용할 수 있는 스레드나 스레드풀이 제한되지 않은 디스패처
제한되지 않았다고 해서 실행 요청된 코루틴이 아무 스레드엥서나 실행되는 것은 아니다.
실행 요청된 코루틴이 이전 코드가 실행되던 스레드에서 계속해서 실행되도록 한다.

---
자식 코루틴들은 기본적으로 부모 코루틴의 CoroutineDispatcher 객체를 사용한다.
따라서 특정 CoroutineDispatcher에서 여러 작업을 실행해야 한다면 부모 코루틴에 CoroutineDispatcher를 설정하고, 그 아래에 자식 코루틴을 여러 개 생성하면 된다.

## 미리 정의된 CoroutineDispatcher
- Dispatchers.IO: 네트워크 요청이나 파일 입출력 등의 I/O 작업을 위한 디스패처
- Dispatchers.Default: CPU를 많이 사용하는 연산 작업을 위한 디스패처
- Dispatchers.Main: 메인 스레드를 사용하기 위한 디스패처

### Dispatchers.IO
네트워크 통신을 위해 HTTP 요청을 하거나, DB작업 같은 입출력 작업 여러 개를 동시에 수행하므로 이런 요청을 동시에 수행하기 위해서는 많은 스레드가 필요.
이를 위해 코루틴 라이브러리에서는 입출력 작업을 위해 미리 정의된 Dispatchers.IO제공

Dispatchers.IO는 싱글톤 인스턴스이므로 launch  함수의 인자로 곧바로 넘겨 사용할 수 있다.
스레드 이름이 DefaultDispatcher-worker가 붙은 이유는 코루틴 라이브러리에서 제공하는 공유 스레드풀에 속한 스레드로 공유 스레드풀의 스레드를 사용할 수 있도록 구현됐기 때문


### Dispatchers.Default
대용량 데이터를 처리해야 하는 작업처럼 CPU 연산이 필요한 작업이 있다.
이런 작업을 CPU 바운드 작업이라고 한다. Dispatchers.Default는 CPU 바운드 작업이 필요할 때 사용

#### limitedParallelism 사용해 Dispatchers.Default 스레드 사용 제한하기
너무 무겁고 오래 걸리는 연산을 처리할 때 모든 스레드가 다 사용되어 다른 연산이 실행되지 못할 수 있다.
이 때 limitedParallelism 함수를 사용해서 스레드의 개수를 제한한다.

그러나 Dispatchers.IO의 limitedParallelism 은 조금 다르다.

limitedParallelism을 사용하면 Default가 사용할 수 있는 스레드 중 일부만을 사용하도록 할 수 있었다.
하지만 IO는 공유 스레드풀의 스레드로 구성된 새로운 스레드 풀을 만들어내며, 만들어낼 수 있는 스레드에 제한이 있는 IO나 Default와 달리 스레드의 수를 제한 없이 만들어낼 수 있다.
그렇다면 언제 IO의 limitedParallelism을 사용할가? =  
#### 바로 특정한 작업이 다른 작업에 영향을 받지 않아야 할 때, 별도 스레드 풀에서 실행되는 것이 필요할 때 
다만 이 함수는 공유 스레드 풀에서 새로운 스레드를 만들어내고, 새로운 스레드 생성은 비싼 작업이므로 남용하지말자.

### 입출력 작업과 CPU 바운드 작업
입출력 작업 = 스레드를 계속 사용하지 않음
CPU 바운드 작업 = 작업을 하는 동안 스레드를 지속적으로 사용

즉 입출력 작업 => 스레드 기반 시(느림) / 코루틴 사용시(빠름)
CPU 바운드 작업 => 스레드 기반(비슷) / 코루틴 사용(비슷)

---
## 공유 스레드풀을 사용하는 IO와 Default
두 디스패처 모두 스레드의 이름이 DefaultDispatcher-worker-n 이다.
이는 서로 같은 스레드풀을 사용한다는 것을 의미한다.

어덯게 같은 스레드풀을 사용할 수 있을까?
IO / Default은 코루틴 라이브러리의 공유 스레드풀을 사용하기 때문이다.

코루틴 라이브러리는 스레드의 생성과 관리를 효율적으로 할 수 있도록 애플리케이션 레벨의 공유 스레드풀을 제공
이 공유 스레드풀에서는 스레드를 무제한으로 생성할 수 있으며, 코루틴 라이브러리는 공유 스레드풀에 스레드를 생성하고 사용할 수 있도록 API제공.
#### 물론 IO와 Default가 사용하는 스레드는 구분된다.
두 녀석 다 공유 스레드풀의 스레드를 사용한다는 것이 중요!!
---

## Dispatchers.Main
UI가 있는 애플리케이션에서 메인 스레드의 사용을 위해 사용되는 특별한 CoroutineDispatcher객체.
