## 코루틴 빌더와 JOB
이전에 코루틴 스코프를 생성하려면 runBlocking, launch를 사용했는데 
코루틴 빌더 함수라고 불리는데 코루틴 빌더 함수가 호출되면 새로운 코루틴이 생성된다.

모든 코루틴 빌더 함수는 코루틴을 만들고 코루틴을 추상화한 Job 객체를 생성한다.

코루틴을 추상화한 Job 객체는 코루틴을 제어할 수 있는 함수와 코루틴의 상태를 나타내는 상태 값들을 외부에 노출한다.
---
## join을 사용한 코루틴 순차처리
코루틴 간 순차 처리가 필요한 경우가 종종 생긴다.
데이터베이스 작업을 순차적으로 처리해야 하는 상황이나 캐싱된 토큰 값이 업데이트된 이후에 네트워크 요청을 해야 하는 상황 등등

그래서 Job 객체는 순차 처리가 필요한 상황을 위해 join 함수를 제공해 먼저 처리해돼야 하는 코루틴의 실행이 완료될 때까지 호출부의 코루틴을 일시 중단하도록 만들 수 있다.

### 순차 처리가 안 될 경우의 문제
네트워크 요청 시 인증 토큰이 필요한 상황에 대해 가정해보자.
이런 경우 인증 토큰이 업데이트가 된 이후 네트워크 요청이 실행돼야 요청이 정상적으로 처리될 수 있다.
만약 인증 토큰 업데이트 이전에 네트워크 요청이 실행된다면 문제가 생길 것이다.

객체.join() 을 호출하면 runBlocking 코루틴은 해당 객체의 코루틴이 완료될 때까지 일시 중단된다.
이후 모두 실행되면 다시 재개된다.

join 함수는 join을 호출한 코루틴만 일시 중단한다.
이미 실행 중인 다른 코루틴을 일시 중단하지는 않는다.

## joinAll을 사용한 코루틴 순차 처리
실제 개발 시에는 서로 독립적인 여러 코루틴을 병렬로 실행한 후 실행한 요청들이 모두 끝날 때까지 기다렸다가 다음 작업을 진행하는 것이 효율적이다.
예를 들어 SNS 앱의 이미지 업로드 기능을 개발한다고 가정해보자.
이 경우 사용자가 복수의 이미지를 선택했다면, 잉미지를 모두 변환한 후 업로드 작업을 진행하도록 만들어야 한다.
이때 이미지의 개수가 3개라고 하면, 코루틴을 하나만 만들어 한 번에 이미지를 하나씩 변환하기보다 코루틴을 세 개 만들어 각 이미지 변환 작업을 병렬로 실행한 후 결과를 취합해 업로드 작업을 실행하는 것이 효율적이다.
<이미지 변환작업은 CPU 바운드 작업이므로 Defaul>

---
## CoroutineStart.LAZY 사용해 코루틴 지연 시작하기
launch는 코루틴을 생성하면 사용할 수 있는 스레드가 있는 경우 곧바로 실행됨
하지만 낮우에 실행돼야 할 코루틴을 미리 생성해야 할 수 있다.

코루틴 객체를 시작 후(start를 LAZY로 설정) 객체.start()로 시작

## 코루틴 취소하기
코루틴이 실행될 필요가 없어졌음에도 취소하지 않고 계속해서 실행되도록 두면 코루틴은 계속해서 스레드를 사용하며 이는 성능 저하로 이어짐
이런 문제를 해결하기 위해 Job 객체는 코루틴을 취소할 수 있는 cancel 함수를 제공한다.

### cancelAndJoin을 사용한 순차처리
!중요
Job 객체에 cancel을 호출하면 코루틴이 즉시 취소되는 것이 아니라 Job 객체 내부의 취소 확인용 플래그를 '취소 요청됨'으로 변경함으로써 코루틴이 취소돼야 한다는 것만 알린다.
이후 미래의 어느 시점에 코루틴의 취소가 요청됐는지 체크하고 취소된다.

즉 cancel 함수를 사용하면 cancel의 대상이 된 Job 객체는 곧바로 취소되는 것이 아니라 미래의 어느 시점에 취소된다.
이런 문제 때문에 이처럼 코드를 작성하면 코루틴이 취소된 이후에 executeAfterJobCancelled 함수가 실행되는 것을 보장할 수 없다.

---
## 취소확인
delay나 yield를 사용해서 취소를 확인할 수 있지만 이 둘은 스레드 사용이 양보되거나 delay만큼 중단되기 때문에 
비효율적이다
그렇기에 CoroutineScope의 `isActive` 를 사용한다.